// Markdown report generation.
//
// Produces a .md file with the full threat report, including ranked accounts,
// evidence (toxic posts), and the protected user's topic fingerprint.
// This format is easy to review, share, and version-control.

use anyhow::Result;
use chrono::Utc;
use std::fmt::Write;

use crate::db::models::AccountScore;
use crate::topics::fingerprint::TopicFingerprint;

/// Generate a markdown threat report and write it to a file.
///
/// Returns the path the report was written to.
pub fn generate_report(
    accounts: &[AccountScore],
    fingerprint: Option<&TopicFingerprint>,
    output_path: &str,
) -> Result<String> {
    let mut md = String::new();

    let timestamp = Utc::now().format("%Y-%m-%d %H:%M UTC");

    writeln!(md, "# Charcoal Threat Report")?;
    writeln!(md)?;
    writeln!(md, "Generated: {timestamp}")?;
    writeln!(md)?;

    // Summary statistics
    let total = accounts.len();
    let high = accounts
        .iter()
        .filter(|a| a.threat_tier.as_deref() == Some("High"))
        .count();
    let elevated = accounts
        .iter()
        .filter(|a| a.threat_tier.as_deref() == Some("Elevated"))
        .count();
    let watch = accounts
        .iter()
        .filter(|a| a.threat_tier.as_deref() == Some("Watch"))
        .count();
    let low = total - high - elevated - watch;

    writeln!(md, "## Summary")?;
    writeln!(md)?;
    writeln!(md, "| Tier | Count |")?;
    writeln!(md, "|------|-------|")?;
    writeln!(md, "| High | {high} |")?;
    writeln!(md, "| Elevated | {elevated} |")?;
    writeln!(md, "| Watch | {watch} |")?;
    writeln!(md, "| Low | {low} |")?;
    writeln!(md, "| **Total** | **{total}** |")?;
    writeln!(md)?;

    // Topic fingerprint (if available)
    if let Some(fp) = fingerprint {
        writeln!(md, "## Protected User Topic Fingerprint")?;
        writeln!(md)?;
        writeln!(
            md,
            "Based on {} recent posts:",
            fp.post_count
        )?;
        writeln!(md)?;

        for (i, cluster) in fp.clusters.iter().enumerate() {
            writeln!(
                md,
                "{}. **{}** (weight: {:.2}) â€” {}",
                i + 1,
                cluster.label,
                cluster.weight,
                cluster.keywords.join(", ")
            )?;
        }
        writeln!(md)?;
    }

    // Ranked threat list
    writeln!(md, "## Ranked Accounts")?;
    writeln!(md)?;
    writeln!(
        md,
        "| Rank | Handle | Score | Tier | Toxicity | Overlap | Posts |"
    )?;
    writeln!(
        md,
        "|------|--------|-------|------|----------|---------|-------|"
    )?;

    for (i, account) in accounts.iter().enumerate() {
        writeln!(
            md,
            "| {} | @{} | {:.1} | {} | {:.2} | {:.2} | {} |",
            i + 1,
            account.handle,
            account.threat_score.unwrap_or(0.0),
            account.threat_tier.as_deref().unwrap_or("?"),
            account.toxicity_score.unwrap_or(0.0),
            account.topic_overlap.unwrap_or(0.0),
            account.posts_analyzed,
        )?;
    }
    writeln!(md)?;

    // Detailed evidence for elevated+ accounts
    let high_priority: Vec<&AccountScore> = accounts
        .iter()
        .filter(|a| {
            a.threat_score.is_some_and(|s| s >= 51.0)
        })
        .collect();

    if !high_priority.is_empty() {
        writeln!(md, "## Evidence (Elevated+ Accounts)")?;
        writeln!(md)?;

        for account in &high_priority {
            writeln!(md, "### @{}", account.handle)?;
            writeln!(md)?;
            writeln!(
                md,
                "- **Score:** {:.1} ({})",
                account.threat_score.unwrap_or(0.0),
                account.threat_tier.as_deref().unwrap_or("?")
            )?;
            writeln!(
                md,
                "- **Toxicity:** {:.2}",
                account.toxicity_score.unwrap_or(0.0)
            )?;
            writeln!(
                md,
                "- **Topic overlap:** {:.2}",
                account.topic_overlap.unwrap_or(0.0)
            )?;
            writeln!(md)?;

            if !account.top_toxic_posts.is_empty() {
                writeln!(md, "**Most toxic posts:**")?;
                writeln!(md)?;
                for (j, post) in account.top_toxic_posts.iter().enumerate() {
                    writeln!(
                        md,
                        "{}. \\[tox: {:.2}\\] {}",
                        j + 1,
                        post.toxicity,
                        post.text.replace('\n', " ")
                    )?;
                }
                writeln!(md)?;
            }
        }
    }

    writeln!(md, "---")?;
    writeln!(md, "*Generated by [Charcoal](https://github.com/dollspace-gay/charcoal)*")?;

    // Write to file
    std::fs::write(output_path, &md)?;

    Ok(output_path.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::db::models::ToxicPost;

    #[test]
    fn test_generate_report() {
        let accounts = vec![
            AccountScore {
                did: "did:plc:abc".to_string(),
                handle: "hostile.bsky.social".to_string(),
                toxicity_score: Some(0.85),
                topic_overlap: Some(0.3),
                threat_score: Some(67.5),
                threat_tier: Some("Elevated".to_string()),
                posts_analyzed: 20,
                top_toxic_posts: vec![ToxicPost {
                    text: "This is a toxic post example".to_string(),
                    toxicity: 0.92,
                    uri: "at://did:plc:abc/post/123".to_string(),
                }],
                scored_at: "2026-02-08".to_string(),
            },
            AccountScore {
                did: "did:plc:def".to_string(),
                handle: "mild.bsky.social".to_string(),
                toxicity_score: Some(0.3),
                topic_overlap: Some(0.1),
                threat_score: Some(24.0),
                threat_tier: Some("Low".to_string()),
                posts_analyzed: 15,
                top_toxic_posts: vec![],
                scored_at: "2026-02-08".to_string(),
            },
        ];

        let tmp_path = "/tmp/charcoal_test_report.md";
        let result = generate_report(&accounts, None, tmp_path);
        assert!(result.is_ok());

        let content = std::fs::read_to_string(tmp_path).unwrap();
        assert!(content.contains("# Charcoal Threat Report"));
        assert!(content.contains("hostile.bsky.social"));
        assert!(content.contains("Elevated"));
        assert!(content.contains("Evidence"));
        assert!(content.contains("toxic post example"));

        // Clean up
        let _ = std::fs::remove_file(tmp_path);
    }
}
